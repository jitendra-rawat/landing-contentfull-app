"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@contentful";
exports.ids = ["vendor-chunks/@contentful"];
exports.modules = {

/***/ "(rsc)/./node_modules/@contentful/content-source-maps/dist/index.js":
/*!********************************************************************!*\
  !*** ./node_modules/@contentful/content-source-maps/dist/index.js ***!
  \********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   SUPPORTED_WIDGETS: () => (/* binding */ ce),\n/* harmony export */   clone: () => (/* binding */ Q),\n/* harmony export */   combine: () => (/* binding */ w),\n/* harmony export */   createSourceMapMetadata: () => (/* binding */ C),\n/* harmony export */   decode: () => (/* binding */ ae),\n/* harmony export */   encode: () => (/* binding */ ie),\n/* harmony export */   encodeCPAResponse: () => (/* binding */ le),\n/* harmony export */   encodeField: () => (/* binding */ P),\n/* harmony export */   encodeGraphQLResponse: () => (/* binding */ fe),\n/* harmony export */   encodeRichTextValue: () => (/* binding */ oe),\n/* harmony export */   isBuiltinNamespace: () => (/* binding */ B),\n/* harmony export */   isSupportedWidget: () => (/* binding */ D),\n/* harmony export */   splitEncoding: () => (/* binding */ ue)\n/* harmony export */ });\nvar W = { 0: 8203, 1: 8204, 2: 8205, 3: 8290, 4: 8291, 5: 8288, 6: 65279, 7: 8289, 8: 119155, 9: 119156, a: 119157, b: 119158, c: 119159, d: 119160, e: 119161, f: 119162 }, L = { 0: 8203, 1: 8204, 2: 8205, 3: 65279 }, j = new Array(4).fill(String.fromCodePoint(L[0])).join(\"\"), V = \"\\0\";\nfunction U(t) {\n  let n = JSON.stringify(t);\n  return `${j}${Array.from(n).map((o) => {\n    let e = o.charCodeAt(0);\n    if (e > 255) throw new Error(`Only ASCII edit info can be encoded. Error attempting to encode ${n} on character ${o} (${e})`);\n    return Array.from(e.toString(4).padStart(4, \"0\")).map((r) => String.fromCodePoint(L[r])).join(\"\");\n  }).join(\"\")}`;\n}\nfunction Z(t) {\n  return !Number.isNaN(Number(t)) || /[a-z]/i.test(t) && !/\\d+(?:[-:\\/]\\d+){2}(?:T\\d+(?:[-:\\/]\\d+){1,2}(\\.\\d+)?Z?)?/.test(t) ? !1 : !!Date.parse(t);\n}\nfunction q(t) {\n  try {\n    new URL(t, t.startsWith(\"/\") ? \"https://acme.com\" : void 0);\n  } catch (n) {\n    return !1;\n  }\n  return !0;\n}\nfunction G(t, n, o = \"auto\") {\n  return o === !0 || o === \"auto\" && (Z(t) || q(t)) ? t : `${t}${U(n)}`;\n}\nvar H = Object.fromEntries(Object.entries(L).map((t) => t.reverse())), F = Object.fromEntries(Object.entries(W).map((t) => t.reverse())), K = `${Object.values(W).map((t) => `\\\\u{${t.toString(16)}}`).join(\"\")}`, O = new RegExp(`[${K}]{4,}`, \"gu\");\nfunction X(t) {\n  let n = t.match(O);\n  if (n) return Y(n[0], !0)[0];\n}\nfunction Y(t, n = !1) {\n  let o = Array.from(t);\n  if (o.length % 2 === 0) {\n    if (o.length % 4 || !t.startsWith(j)) return ee(o, n);\n  } else throw new Error(\"Encoded data has invalid length\");\n  let e = [];\n  for (let r = o.length * 0.25; r--; ) {\n    let s = o.slice(r * 4, r * 4 + 4).map((c) => H[c.codePointAt(0)]).join(\"\");\n    e.unshift(String.fromCharCode(parseInt(s, 4)));\n  }\n  if (n) {\n    e.shift();\n    let r = e.indexOf(V);\n    return r === -1 && (r = e.length), [JSON.parse(e.slice(0, r).join(\"\"))];\n  }\n  return e.join(\"\").split(V).filter(Boolean).map((r) => JSON.parse(r));\n}\nfunction ee(t, n) {\n  var o;\n  let e = [];\n  for (let i = t.length * 0.5; i--; ) {\n    let u = `${F[t[i * 2].codePointAt(0)]}${F[t[i * 2 + 1].codePointAt(0)]}`;\n    e.unshift(String.fromCharCode(parseInt(u, 16)));\n  }\n  let r = [], s = [e.join(\"\")], c = 10;\n  for (; s.length; ) {\n    let i = s.shift();\n    try {\n      if (r.push(JSON.parse(i)), n) return r;\n    } catch (u) {\n      if (!c--) throw u;\n      let a = +((o = u.message.match(/\\sposition\\s(\\d+)$/)) == null ? void 0 : o[1]);\n      if (!a) throw u;\n      s.unshift(i.substring(0, a), i.substring(a));\n    }\n  }\n  return r;\n}\nfunction te(t) {\n  var n;\n  return { cleaned: t.replace(O, \"\"), encoded: ((n = t.match(O)) == null ? void 0 : n[0]) || \"\" };\n}\nfunction w(t, n) {\n  return G(t, n);\n}\nfunction ie(t) {\n  return U(t);\n}\nfunction ae(t) {\n  return X(t);\n}\nfunction ue(t) {\n  return te(t);\n}\nvar x, k;\nfunction ne() {\n  if (k) return x;\n  k = 1;\n  var t = Object.prototype.hasOwnProperty, n = Object.prototype.toString;\n  return x = function(e, r, s) {\n    if (n.call(r) !== \"[object Function]\")\n      throw new TypeError(\"iterator must be a function\");\n    var c = e.length;\n    if (c === +c)\n      for (var i = 0; i < c; i++)\n        r.call(s, e[i], i, e);\n    else\n      for (var u in e)\n        t.call(e, u) && r.call(s, e[u], u, e);\n  }, x;\n}\nvar I, _;\nfunction re() {\n  if (_) return I;\n  _ = 1;\n  var t = ne();\n  I = n;\n  function n(o, e, r) {\n    if (arguments.length === 3)\n      return n.set(o, e, r);\n    if (arguments.length === 2)\n      return n.get(o, e);\n    var s = n.bind(n, o);\n    for (var c in n)\n      n.hasOwnProperty(c) && (s[c] = n[c].bind(s, o));\n    return s;\n  }\n  return n.get = function(e, r) {\n    for (var s = Array.isArray(r) ? r : n.parse(r), c = 0; c < s.length; ++c) {\n      var i = s[c];\n      if (!(typeof e == \"object\" && i in e))\n        throw new Error(\"Invalid reference token: \" + i);\n      e = e[i];\n    }\n    return e;\n  }, n.set = function(e, r, s) {\n    var c = Array.isArray(r) ? r : n.parse(r), i = c[0];\n    if (c.length === 0)\n      throw Error(\"Can not set the root object\");\n    for (var u = 0; u < c.length - 1; ++u) {\n      var a = c[u];\n      typeof a != \"string\" && typeof a != \"number\" && (a = String(a)), !(a === \"__proto__\" || a === \"constructor\" || a === \"prototype\") && (a === \"-\" && Array.isArray(e) && (a = e.length), i = c[u + 1], a in e || (i.match(/^(\\d+|-)$/) ? e[a] = [] : e[a] = {}), e = e[a]);\n    }\n    return i === \"-\" && Array.isArray(e) && (i = e.length), e[i] = s, this;\n  }, n.remove = function(o, e) {\n    var r = Array.isArray(e) ? e : n.parse(e), s = r[r.length - 1];\n    if (s === void 0)\n      throw new Error('Invalid JSON pointer for remove: \"' + e + '\"');\n    var c = n.get(o, r.slice(0, -1));\n    if (Array.isArray(c)) {\n      var i = +s;\n      if (s === \"\" && isNaN(i))\n        throw new Error('Invalid array index: \"' + s + '\"');\n      Array.prototype.splice.call(c, i, 1);\n    } else\n      delete c[s];\n  }, n.dict = function(e, r) {\n    var s = {};\n    return n.walk(e, function(c, i) {\n      s[i] = c;\n    }, r), s;\n  }, n.walk = function(e, r, s) {\n    var c = [];\n    s = s || function(i) {\n      var u = Object.prototype.toString.call(i);\n      return u === \"[object Object]\" || u === \"[object Array]\";\n    }, function i(u) {\n      t(u, function(a, l) {\n        c.push(String(l)), s(a) ? i(a) : r(a, n.compile(c)), c.pop();\n      });\n    }(e);\n  }, n.has = function(e, r) {\n    try {\n      n.get(e, r);\n    } catch (s) {\n      return !1;\n    }\n    return !0;\n  }, n.escape = function(e) {\n    return e.toString().replace(/~/g, \"~0\").replace(/\\//g, \"~1\");\n  }, n.unescape = function(e) {\n    return e.replace(/~1/g, \"/\").replace(/~0/g, \"~\");\n  }, n.parse = function(e) {\n    if (e === \"\")\n      return [];\n    if (e.charAt(0) !== \"/\")\n      throw new Error(\"Invalid JSON pointer: \" + e);\n    return e.substring(1).split(/\\//).map(n.unescape);\n  }, n.compile = function(e) {\n    return e.length === 0 ? \"\" : \"/\" + e.map(n.escape).join(\"/\");\n  }, I;\n}\nvar p = re();\nconst oe = ({\n  pointer: t,\n  mappings: n,\n  data: o,\n  hiddenStrings: e\n}) => {\n  const r = n[t];\n  if (r) {\n    delete n[t];\n    const s = b(o, t);\n    for (const c of s) {\n      n[c] = r;\n      const i = p.get(o, c), u = w(i, e);\n      p.set(o, c, u);\n    }\n  } else {\n    const s = b(o, t);\n    for (const c of s) {\n      const i = p.get(o, c), u = w(i, e);\n      p.set(o, c, u);\n    }\n  }\n};\nfunction se(t) {\n  return \"content\" in t && !!t.content;\n}\nconst b = (t, n = \"\") => {\n  const o = [], e = p.get(t, n);\n  if (se(e))\n    for (let r = 0; r < e.content.length; r++)\n      e.content[r].nodeType === \"text\" ? o.push(`${n}/content/${r}/value`) : o.push(...b(t, `${n}/content/${r}`));\n  return o;\n}, C = ({\n  entityId: t,\n  entityType: n,\n  space: o,\n  environment: e,\n  field: r,\n  locale: s,\n  editorInterface: c,\n  fieldType: i,\n  targetOrigin: u,\n  platform: a\n}) => {\n  const d = {\n    origin: \"contentful.com\",\n    href: `${`${u || \"https://app.contentful.com\"}/spaces/${o}/environments/${e}`}/${n === \"Entry\" ? \"entries\" : \"assets\"}/${t}/?focusedField=${r}&focusedLocale=${s}&source=vercel-content-link`,\n    contentful: {\n      editorInterface: c,\n      fieldType: i\n    }\n  };\n  return a === \"vercel\" && delete d.contentful, d;\n}, B = (t) => [\"builtin\", \"sidebar-builtin\", \"editor-builtin\"].includes(t), D = (t) => ce.includes(t);\nfunction Q(t) {\n  if (typeof structuredClone == \"function\")\n    return structuredClone(t);\n  try {\n    return JSON.parse(JSON.stringify(t));\n  } catch (n) {\n    return console.warn(\"Failed to clone data:\", t, n), t;\n  }\n}\nconst ce = [\n  \"singleLine\",\n  \"tagEditor\",\n  \"listInput\",\n  \"checkbox\",\n  \"richTextEditor\",\n  \"multipleLine\"\n];\nfunction P(t, n, o, e, r, s, c) {\n  const i = c ? n[c] : n;\n  switch (t) {\n    case \"Symbol\": {\n      const u = w(i, o);\n      p.set(e, r, u);\n      break;\n    }\n    case \"Text\": {\n      const u = w(i, o);\n      p.set(e, r, u);\n      break;\n    }\n    case \"RichText\": {\n      oe({\n        pointer: \"\",\n        mappings: s,\n        data: i,\n        hiddenStrings: o\n      });\n      break;\n    }\n    case \"Array\": {\n      const u = i.map((a) => typeof a == \"string\" ? w(a, o) : a);\n      p.set(e, r, u);\n      break;\n    }\n  }\n}\nconst fe = (t, n, o) => {\n  if (!t || !t.extensions || !t.extensions.contentSourceMaps)\n    return console.error(\n      \"GraphQL response does not contain Content Source Maps information.\",\n      t\n    ), t;\n  const e = Q(t), {\n    spaces: r,\n    environments: s,\n    editorInterfaces: c,\n    fields: i,\n    locales: u,\n    entries: a,\n    assets: l,\n    mappings: m,\n    fieldTypes: v\n  } = e.extensions.contentSourceMaps, y = e;\n  for (const d in m) {\n    const { source: f } = m[d], h = \"entry\" in f ? a[f.entry] : l[f.asset], M = \"entry\" in f ? \"Entry\" : \"Asset\";\n    if (!h)\n      return e;\n    const g = r[h.space], A = s[h.environment], E = h.id, S = i[f.field], T = u[f.locale], N = c[f.editorInterface], J = v[f.fieldType];\n    if (!(B(N.widgetNamespace) && !D(N.widgetId)) && p.has(y, d)) {\n      const R = p.get(y, d);\n      if (R !== null) {\n        const z = C({\n          entityId: E,\n          entityType: M,\n          space: g,\n          environment: A,\n          field: S,\n          locale: T,\n          editorInterface: N,\n          fieldType: J,\n          targetOrigin: n,\n          platform: o\n        });\n        P(J, R, z, y, d, m);\n      }\n    }\n  }\n  return e;\n}, $ = (t, n, o, e, r) => {\n  if (!t.fields)\n    return;\n  const { contentSourceMaps: s } = t.sys;\n  if (!s)\n    return;\n  const { mappings: c } = s;\n  for (const i in c) {\n    const { source: u } = c[i], a = t.sys.space.sys.id, l = t.sys.environment.sys.id, m = t.sys.id, v = t.sys.type, y = n[u.fieldType], d = o[u.editorInterface];\n    if (B(d.widgetNamespace) && !D(d.widgetId))\n      continue;\n    const f = i.startsWith(\"/\") ? i : `/${i}`;\n    if (p.has(t, f)) {\n      const h = p.get(t, f);\n      if (h === null)\n        return;\n      const g = f.split(\"/\").pop();\n      if (!g) {\n        console.error(\"Field name could not be extracted from the pointer\", f);\n        return;\n      }\n      const A = t.sys.locale;\n      if (A) {\n        const E = C({\n          entityId: m,\n          entityType: v,\n          space: a,\n          environment: l,\n          field: g,\n          locale: A,\n          editorInterface: d,\n          fieldType: y,\n          targetOrigin: e,\n          platform: r\n        });\n        P(y, h, E, t, f, c);\n      } else\n        Object.keys(h).forEach((S) => {\n          const T = C({\n            entityId: m,\n            entityType: v,\n            space: a,\n            environment: l,\n            field: g,\n            locale: S,\n            editorInterface: d,\n            fieldType: y,\n            targetOrigin: e,\n            platform: r\n          });\n          P(\n            y,\n            h,\n            T,\n            t,\n            `${f}/${S}`,\n            c,\n            S\n          );\n        });\n    }\n  }\n}, le = (t, n, o) => {\n  var r;\n  const e = Q(\n    t\n  );\n  if (e.sys && \"items\" in e) {\n    const s = e;\n    if (!((r = s.sys) != null && r.contentSourceMapsLookup))\n      return s;\n    const {\n      contentSourceMapsLookup: { fieldTypes: c, editorInterfaces: i }\n    } = s.sys, { items: u, includes: a } = s;\n    u.forEach(\n      (l) => $(l, c, i, n, o)\n    ), a && a.Entry && a.Entry.forEach(\n      (l) => $(l, c, i, n, o)\n    ), a && a.Asset && a.Asset.forEach(\n      (l) => $(l, c, i, n, o)\n    );\n  } else {\n    const s = e;\n    if (!s.sys.contentSourceMapsLookup)\n      return console.error(\"Content source maps lookup data is missing\"), s;\n    $(\n      s,\n      s.sys.contentSourceMapsLookup.fieldTypes,\n      s.sys.contentSourceMapsLookup.editorInterfaces,\n      n,\n      o\n    );\n  }\n  return e;\n};\n\n//# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGNvbnRlbnRmdWwvY29udGVudC1zb3VyY2UtbWFwcy9kaXN0L2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQSxVQUFVLGlLQUFpSyxRQUFRLHFDQUFxQztBQUN4TjtBQUNBO0FBQ0EsWUFBWSxFQUFFLEVBQUU7QUFDaEI7QUFDQSxvR0FBb0csR0FBRyxlQUFlLEdBQUcsR0FBRyxFQUFFO0FBQzlIO0FBQ0EsR0FBRyxXQUFXO0FBQ2Q7QUFDQTtBQUNBLDRFQUE0RSxFQUFFLHFCQUFxQixJQUFJO0FBQ3ZHO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2REFBNkQsRUFBRSxFQUFFLEtBQUs7QUFDdEU7QUFDQSxpSkFBaUosaUNBQWlDLEVBQUUsZ0JBQWdCLFlBQVksc0JBQXNCLEVBQUUsRUFBRSxHQUFHO0FBQzdPO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxnQ0FBZ0MsS0FBSztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixLQUFLO0FBQ3BDLGVBQWUsMkJBQTJCLEVBQUUsK0JBQStCO0FBQzNFO0FBQ0E7QUFDQTtBQUNBLFNBQVMsVUFBVTtBQUNuQjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixPQUFPO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FB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QUFHLEVBQUU7QUFDdEI7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDLE1BQU0sV0FBVyx3QkFBd0I7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFlRTtBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY29udGVudGZ1bC1sYW5kaW5nLXBhZ2UtYnVpbGRlci8uL25vZGVfbW9kdWxlcy9AY29udGVudGZ1bC9jb250ZW50LXNvdXJjZS1tYXBzL2Rpc3QvaW5kZXguanM/Y2E5OSJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgVyA9IHsgMDogODIwMywgMTogODIwNCwgMjogODIwNSwgMzogODI5MCwgNDogODI5MSwgNTogODI4OCwgNjogNjUyNzksIDc6IDgyODksIDg6IDExOTE1NSwgOTogMTE5MTU2LCBhOiAxMTkxNTcsIGI6IDExOTE1OCwgYzogMTE5MTU5LCBkOiAxMTkxNjAsIGU6IDExOTE2MSwgZjogMTE5MTYyIH0sIEwgPSB7IDA6IDgyMDMsIDE6IDgyMDQsIDI6IDgyMDUsIDM6IDY1Mjc5IH0sIGogPSBuZXcgQXJyYXkoNCkuZmlsbChTdHJpbmcuZnJvbUNvZGVQb2ludChMWzBdKSkuam9pbihcIlwiKSwgViA9IFwiXFwwXCI7XG5mdW5jdGlvbiBVKHQpIHtcbiAgbGV0IG4gPSBKU09OLnN0cmluZ2lmeSh0KTtcbiAgcmV0dXJuIGAke2p9JHtBcnJheS5mcm9tKG4pLm1hcCgobykgPT4ge1xuICAgIGxldCBlID0gby5jaGFyQ29kZUF0KDApO1xuICAgIGlmIChlID4gMjU1KSB0aHJvdyBuZXcgRXJyb3IoYE9ubHkgQVNDSUkgZWRpdCBpbmZvIGNhbiBiZSBlbmNvZGVkLiBFcnJvciBhdHRlbXB0aW5nIHRvIGVuY29kZSAke259IG9uIGNoYXJhY3RlciAke299ICgke2V9KWApO1xuICAgIHJldHVybiBBcnJheS5mcm9tKGUudG9TdHJpbmcoNCkucGFkU3RhcnQoNCwgXCIwXCIpKS5tYXAoKHIpID0+IFN0cmluZy5mcm9tQ29kZVBvaW50KExbcl0pKS5qb2luKFwiXCIpO1xuICB9KS5qb2luKFwiXCIpfWA7XG59XG5mdW5jdGlvbiBaKHQpIHtcbiAgcmV0dXJuICFOdW1iZXIuaXNOYU4oTnVtYmVyKHQpKSB8fCAvW2Etel0vaS50ZXN0KHQpICYmICEvXFxkKyg/OlstOlxcL11cXGQrKXsyfSg/OlRcXGQrKD86Wy06XFwvXVxcZCspezEsMn0oXFwuXFxkKyk/Wj8pPy8udGVzdCh0KSA/ICExIDogISFEYXRlLnBhcnNlKHQpO1xufVxuZnVuY3Rpb24gcSh0KSB7XG4gIHRyeSB7XG4gICAgbmV3IFVSTCh0LCB0LnN0YXJ0c1dpdGgoXCIvXCIpID8gXCJodHRwczovL2FjbWUuY29tXCIgOiB2b2lkIDApO1xuICB9IGNhdGNoIChuKSB7XG4gICAgcmV0dXJuICExO1xuICB9XG4gIHJldHVybiAhMDtcbn1cbmZ1bmN0aW9uIEcodCwgbiwgbyA9IFwiYXV0b1wiKSB7XG4gIHJldHVybiBvID09PSAhMCB8fCBvID09PSBcImF1dG9cIiAmJiAoWih0KSB8fCBxKHQpKSA/IHQgOiBgJHt0fSR7VShuKX1gO1xufVxudmFyIEggPSBPYmplY3QuZnJvbUVudHJpZXMoT2JqZWN0LmVudHJpZXMoTCkubWFwKCh0KSA9PiB0LnJldmVyc2UoKSkpLCBGID0gT2JqZWN0LmZyb21FbnRyaWVzKE9iamVjdC5lbnRyaWVzKFcpLm1hcCgodCkgPT4gdC5yZXZlcnNlKCkpKSwgSyA9IGAke09iamVjdC52YWx1ZXMoVykubWFwKCh0KSA9PiBgXFxcXHV7JHt0LnRvU3RyaW5nKDE2KX19YCkuam9pbihcIlwiKX1gLCBPID0gbmV3IFJlZ0V4cChgWyR7S31dezQsfWAsIFwiZ3VcIik7XG5mdW5jdGlvbiBYKHQpIHtcbiAgbGV0IG4gPSB0Lm1hdGNoKE8pO1xuICBpZiAobikgcmV0dXJuIFkoblswXSwgITApWzBdO1xufVxuZnVuY3Rpb24gWSh0LCBuID0gITEpIHtcbiAgbGV0IG8gPSBBcnJheS5mcm9tKHQpO1xuICBpZiAoby5sZW5ndGggJSAyID09PSAwKSB7XG4gICAgaWYgKG8ubGVuZ3RoICUgNCB8fCAhdC5zdGFydHNXaXRoKGopKSByZXR1cm4gZWUobywgbik7XG4gIH0gZWxzZSB0aHJvdyBuZXcgRXJyb3IoXCJFbmNvZGVkIGRhdGEgaGFzIGludmFsaWQgbGVuZ3RoXCIpO1xuICBsZXQgZSA9IFtdO1xuICBmb3IgKGxldCByID0gby5sZW5ndGggKiAwLjI1OyByLS07ICkge1xuICAgIGxldCBzID0gby5zbGljZShyICogNCwgciAqIDQgKyA0KS5tYXAoKGMpID0+IEhbYy5jb2RlUG9pbnRBdCgwKV0pLmpvaW4oXCJcIik7XG4gICAgZS51bnNoaWZ0KFN0cmluZy5mcm9tQ2hhckNvZGUocGFyc2VJbnQocywgNCkpKTtcbiAgfVxuICBpZiAobikge1xuICAgIGUuc2hpZnQoKTtcbiAgICBsZXQgciA9IGUuaW5kZXhPZihWKTtcbiAgICByZXR1cm4gciA9PT0gLTEgJiYgKHIgPSBlLmxlbmd0aCksIFtKU09OLnBhcnNlKGUuc2xpY2UoMCwgcikuam9pbihcIlwiKSldO1xuICB9XG4gIHJldHVybiBlLmpvaW4oXCJcIikuc3BsaXQoVikuZmlsdGVyKEJvb2xlYW4pLm1hcCgocikgPT4gSlNPTi5wYXJzZShyKSk7XG59XG5mdW5jdGlvbiBlZSh0LCBuKSB7XG4gIHZhciBvO1xuICBsZXQgZSA9IFtdO1xuICBmb3IgKGxldCBpID0gdC5sZW5ndGggKiAwLjU7IGktLTsgKSB7XG4gICAgbGV0IHUgPSBgJHtGW3RbaSAqIDJdLmNvZGVQb2ludEF0KDApXX0ke0ZbdFtpICogMiArIDFdLmNvZGVQb2ludEF0KDApXX1gO1xuICAgIGUudW5zaGlmdChTdHJpbmcuZnJvbUNoYXJDb2RlKHBhcnNlSW50KHUsIDE2KSkpO1xuICB9XG4gIGxldCByID0gW10sIHMgPSBbZS5qb2luKFwiXCIpXSwgYyA9IDEwO1xuICBmb3IgKDsgcy5sZW5ndGg7ICkge1xuICAgIGxldCBpID0gcy5zaGlmdCgpO1xuICAgIHRyeSB7XG4gICAgICBpZiAoci5wdXNoKEpTT04ucGFyc2UoaSkpLCBuKSByZXR1cm4gcjtcbiAgICB9IGNhdGNoICh1KSB7XG4gICAgICBpZiAoIWMtLSkgdGhyb3cgdTtcbiAgICAgIGxldCBhID0gKygobyA9IHUubWVzc2FnZS5tYXRjaCgvXFxzcG9zaXRpb25cXHMoXFxkKykkLykpID09IG51bGwgPyB2b2lkIDAgOiBvWzFdKTtcbiAgICAgIGlmICghYSkgdGhyb3cgdTtcbiAgICAgIHMudW5zaGlmdChpLnN1YnN0cmluZygwLCBhKSwgaS5zdWJzdHJpbmcoYSkpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcjtcbn1cbmZ1bmN0aW9uIHRlKHQpIHtcbiAgdmFyIG47XG4gIHJldHVybiB7IGNsZWFuZWQ6IHQucmVwbGFjZShPLCBcIlwiKSwgZW5jb2RlZDogKChuID0gdC5tYXRjaChPKSkgPT0gbnVsbCA/IHZvaWQgMCA6IG5bMF0pIHx8IFwiXCIgfTtcbn1cbmZ1bmN0aW9uIHcodCwgbikge1xuICByZXR1cm4gRyh0LCBuKTtcbn1cbmZ1bmN0aW9uIGllKHQpIHtcbiAgcmV0dXJuIFUodCk7XG59XG5mdW5jdGlvbiBhZSh0KSB7XG4gIHJldHVybiBYKHQpO1xufVxuZnVuY3Rpb24gdWUodCkge1xuICByZXR1cm4gdGUodCk7XG59XG52YXIgeCwgaztcbmZ1bmN0aW9uIG5lKCkge1xuICBpZiAoaykgcmV0dXJuIHg7XG4gIGsgPSAxO1xuICB2YXIgdCA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHksIG4gPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xuICByZXR1cm4geCA9IGZ1bmN0aW9uKGUsIHIsIHMpIHtcbiAgICBpZiAobi5jYWxsKHIpICE9PSBcIltvYmplY3QgRnVuY3Rpb25dXCIpXG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiaXRlcmF0b3IgbXVzdCBiZSBhIGZ1bmN0aW9uXCIpO1xuICAgIHZhciBjID0gZS5sZW5ndGg7XG4gICAgaWYgKGMgPT09ICtjKVxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjOyBpKyspXG4gICAgICAgIHIuY2FsbChzLCBlW2ldLCBpLCBlKTtcbiAgICBlbHNlXG4gICAgICBmb3IgKHZhciB1IGluIGUpXG4gICAgICAgIHQuY2FsbChlLCB1KSAmJiByLmNhbGwocywgZVt1XSwgdSwgZSk7XG4gIH0sIHg7XG59XG52YXIgSSwgXztcbmZ1bmN0aW9uIHJlKCkge1xuICBpZiAoXykgcmV0dXJuIEk7XG4gIF8gPSAxO1xuICB2YXIgdCA9IG5lKCk7XG4gIEkgPSBuO1xuICBmdW5jdGlvbiBuKG8sIGUsIHIpIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMylcbiAgICAgIHJldHVybiBuLnNldChvLCBlLCByKTtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMilcbiAgICAgIHJldHVybiBuLmdldChvLCBlKTtcbiAgICB2YXIgcyA9IG4uYmluZChuLCBvKTtcbiAgICBmb3IgKHZhciBjIGluIG4pXG4gICAgICBuLmhhc093blByb3BlcnR5KGMpICYmIChzW2NdID0gbltjXS5iaW5kKHMsIG8pKTtcbiAgICByZXR1cm4gcztcbiAgfVxuICByZXR1cm4gbi5nZXQgPSBmdW5jdGlvbihlLCByKSB7XG4gICAgZm9yICh2YXIgcyA9IEFycmF5LmlzQXJyYXkocikgPyByIDogbi5wYXJzZShyKSwgYyA9IDA7IGMgPCBzLmxlbmd0aDsgKytjKSB7XG4gICAgICB2YXIgaSA9IHNbY107XG4gICAgICBpZiAoISh0eXBlb2YgZSA9PSBcIm9iamVjdFwiICYmIGkgaW4gZSkpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgcmVmZXJlbmNlIHRva2VuOiBcIiArIGkpO1xuICAgICAgZSA9IGVbaV07XG4gICAgfVxuICAgIHJldHVybiBlO1xuICB9LCBuLnNldCA9IGZ1bmN0aW9uKGUsIHIsIHMpIHtcbiAgICB2YXIgYyA9IEFycmF5LmlzQXJyYXkocikgPyByIDogbi5wYXJzZShyKSwgaSA9IGNbMF07XG4gICAgaWYgKGMubGVuZ3RoID09PSAwKVxuICAgICAgdGhyb3cgRXJyb3IoXCJDYW4gbm90IHNldCB0aGUgcm9vdCBvYmplY3RcIik7XG4gICAgZm9yICh2YXIgdSA9IDA7IHUgPCBjLmxlbmd0aCAtIDE7ICsrdSkge1xuICAgICAgdmFyIGEgPSBjW3VdO1xuICAgICAgdHlwZW9mIGEgIT0gXCJzdHJpbmdcIiAmJiB0eXBlb2YgYSAhPSBcIm51bWJlclwiICYmIChhID0gU3RyaW5nKGEpKSwgIShhID09PSBcIl9fcHJvdG9fX1wiIHx8IGEgPT09IFwiY29uc3RydWN0b3JcIiB8fCBhID09PSBcInByb3RvdHlwZVwiKSAmJiAoYSA9PT0gXCItXCIgJiYgQXJyYXkuaXNBcnJheShlKSAmJiAoYSA9IGUubGVuZ3RoKSwgaSA9IGNbdSArIDFdLCBhIGluIGUgfHwgKGkubWF0Y2goL14oXFxkK3wtKSQvKSA/IGVbYV0gPSBbXSA6IGVbYV0gPSB7fSksIGUgPSBlW2FdKTtcbiAgICB9XG4gICAgcmV0dXJuIGkgPT09IFwiLVwiICYmIEFycmF5LmlzQXJyYXkoZSkgJiYgKGkgPSBlLmxlbmd0aCksIGVbaV0gPSBzLCB0aGlzO1xuICB9LCBuLnJlbW92ZSA9IGZ1bmN0aW9uKG8sIGUpIHtcbiAgICB2YXIgciA9IEFycmF5LmlzQXJyYXkoZSkgPyBlIDogbi5wYXJzZShlKSwgcyA9IHJbci5sZW5ndGggLSAxXTtcbiAgICBpZiAocyA9PT0gdm9pZCAwKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIEpTT04gcG9pbnRlciBmb3IgcmVtb3ZlOiBcIicgKyBlICsgJ1wiJyk7XG4gICAgdmFyIGMgPSBuLmdldChvLCByLnNsaWNlKDAsIC0xKSk7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoYykpIHtcbiAgICAgIHZhciBpID0gK3M7XG4gICAgICBpZiAocyA9PT0gXCJcIiAmJiBpc05hTihpKSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGFycmF5IGluZGV4OiBcIicgKyBzICsgJ1wiJyk7XG4gICAgICBBcnJheS5wcm90b3R5cGUuc3BsaWNlLmNhbGwoYywgaSwgMSk7XG4gICAgfSBlbHNlXG4gICAgICBkZWxldGUgY1tzXTtcbiAgfSwgbi5kaWN0ID0gZnVuY3Rpb24oZSwgcikge1xuICAgIHZhciBzID0ge307XG4gICAgcmV0dXJuIG4ud2FsayhlLCBmdW5jdGlvbihjLCBpKSB7XG4gICAgICBzW2ldID0gYztcbiAgICB9LCByKSwgcztcbiAgfSwgbi53YWxrID0gZnVuY3Rpb24oZSwgciwgcykge1xuICAgIHZhciBjID0gW107XG4gICAgcyA9IHMgfHwgZnVuY3Rpb24oaSkge1xuICAgICAgdmFyIHUgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoaSk7XG4gICAgICByZXR1cm4gdSA9PT0gXCJbb2JqZWN0IE9iamVjdF1cIiB8fCB1ID09PSBcIltvYmplY3QgQXJyYXldXCI7XG4gICAgfSwgZnVuY3Rpb24gaSh1KSB7XG4gICAgICB0KHUsIGZ1bmN0aW9uKGEsIGwpIHtcbiAgICAgICAgYy5wdXNoKFN0cmluZyhsKSksIHMoYSkgPyBpKGEpIDogcihhLCBuLmNvbXBpbGUoYykpLCBjLnBvcCgpO1xuICAgICAgfSk7XG4gICAgfShlKTtcbiAgfSwgbi5oYXMgPSBmdW5jdGlvbihlLCByKSB7XG4gICAgdHJ5IHtcbiAgICAgIG4uZ2V0KGUsIHIpO1xuICAgIH0gY2F0Y2ggKHMpIHtcbiAgICAgIHJldHVybiAhMTtcbiAgICB9XG4gICAgcmV0dXJuICEwO1xuICB9LCBuLmVzY2FwZSA9IGZ1bmN0aW9uKGUpIHtcbiAgICByZXR1cm4gZS50b1N0cmluZygpLnJlcGxhY2UoL34vZywgXCJ+MFwiKS5yZXBsYWNlKC9cXC8vZywgXCJ+MVwiKTtcbiAgfSwgbi51bmVzY2FwZSA9IGZ1bmN0aW9uKGUpIHtcbiAgICByZXR1cm4gZS5yZXBsYWNlKC9+MS9nLCBcIi9cIikucmVwbGFjZSgvfjAvZywgXCJ+XCIpO1xuICB9LCBuLnBhcnNlID0gZnVuY3Rpb24oZSkge1xuICAgIGlmIChlID09PSBcIlwiKVxuICAgICAgcmV0dXJuIFtdO1xuICAgIGlmIChlLmNoYXJBdCgwKSAhPT0gXCIvXCIpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIEpTT04gcG9pbnRlcjogXCIgKyBlKTtcbiAgICByZXR1cm4gZS5zdWJzdHJpbmcoMSkuc3BsaXQoL1xcLy8pLm1hcChuLnVuZXNjYXBlKTtcbiAgfSwgbi5jb21waWxlID0gZnVuY3Rpb24oZSkge1xuICAgIHJldHVybiBlLmxlbmd0aCA9PT0gMCA/IFwiXCIgOiBcIi9cIiArIGUubWFwKG4uZXNjYXBlKS5qb2luKFwiL1wiKTtcbiAgfSwgSTtcbn1cbnZhciBwID0gcmUoKTtcbmNvbnN0IG9lID0gKHtcbiAgcG9pbnRlcjogdCxcbiAgbWFwcGluZ3M6IG4sXG4gIGRhdGE6IG8sXG4gIGhpZGRlblN0cmluZ3M6IGVcbn0pID0+IHtcbiAgY29uc3QgciA9IG5bdF07XG4gIGlmIChyKSB7XG4gICAgZGVsZXRlIG5bdF07XG4gICAgY29uc3QgcyA9IGIobywgdCk7XG4gICAgZm9yIChjb25zdCBjIG9mIHMpIHtcbiAgICAgIG5bY10gPSByO1xuICAgICAgY29uc3QgaSA9IHAuZ2V0KG8sIGMpLCB1ID0gdyhpLCBlKTtcbiAgICAgIHAuc2V0KG8sIGMsIHUpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBjb25zdCBzID0gYihvLCB0KTtcbiAgICBmb3IgKGNvbnN0IGMgb2Ygcykge1xuICAgICAgY29uc3QgaSA9IHAuZ2V0KG8sIGMpLCB1ID0gdyhpLCBlKTtcbiAgICAgIHAuc2V0KG8sIGMsIHUpO1xuICAgIH1cbiAgfVxufTtcbmZ1bmN0aW9uIHNlKHQpIHtcbiAgcmV0dXJuIFwiY29udGVudFwiIGluIHQgJiYgISF0LmNvbnRlbnQ7XG59XG5jb25zdCBiID0gKHQsIG4gPSBcIlwiKSA9PiB7XG4gIGNvbnN0IG8gPSBbXSwgZSA9IHAuZ2V0KHQsIG4pO1xuICBpZiAoc2UoZSkpXG4gICAgZm9yIChsZXQgciA9IDA7IHIgPCBlLmNvbnRlbnQubGVuZ3RoOyByKyspXG4gICAgICBlLmNvbnRlbnRbcl0ubm9kZVR5cGUgPT09IFwidGV4dFwiID8gby5wdXNoKGAke259L2NvbnRlbnQvJHtyfS92YWx1ZWApIDogby5wdXNoKC4uLmIodCwgYCR7bn0vY29udGVudC8ke3J9YCkpO1xuICByZXR1cm4gbztcbn0sIEMgPSAoe1xuICBlbnRpdHlJZDogdCxcbiAgZW50aXR5VHlwZTogbixcbiAgc3BhY2U6IG8sXG4gIGVudmlyb25tZW50OiBlLFxuICBmaWVsZDogcixcbiAgbG9jYWxlOiBzLFxuICBlZGl0b3JJbnRlcmZhY2U6IGMsXG4gIGZpZWxkVHlwZTogaSxcbiAgdGFyZ2V0T3JpZ2luOiB1LFxuICBwbGF0Zm9ybTogYVxufSkgPT4ge1xuICBjb25zdCBkID0ge1xuICAgIG9yaWdpbjogXCJjb250ZW50ZnVsLmNvbVwiLFxuICAgIGhyZWY6IGAke2Ake3UgfHwgXCJodHRwczovL2FwcC5jb250ZW50ZnVsLmNvbVwifS9zcGFjZXMvJHtvfS9lbnZpcm9ubWVudHMvJHtlfWB9LyR7biA9PT0gXCJFbnRyeVwiID8gXCJlbnRyaWVzXCIgOiBcImFzc2V0c1wifS8ke3R9Lz9mb2N1c2VkRmllbGQ9JHtyfSZmb2N1c2VkTG9jYWxlPSR7c30mc291cmNlPXZlcmNlbC1jb250ZW50LWxpbmtgLFxuICAgIGNvbnRlbnRmdWw6IHtcbiAgICAgIGVkaXRvckludGVyZmFjZTogYyxcbiAgICAgIGZpZWxkVHlwZTogaVxuICAgIH1cbiAgfTtcbiAgcmV0dXJuIGEgPT09IFwidmVyY2VsXCIgJiYgZGVsZXRlIGQuY29udGVudGZ1bCwgZDtcbn0sIEIgPSAodCkgPT4gW1wiYnVpbHRpblwiLCBcInNpZGViYXItYnVpbHRpblwiLCBcImVkaXRvci1idWlsdGluXCJdLmluY2x1ZGVzKHQpLCBEID0gKHQpID0+IGNlLmluY2x1ZGVzKHQpO1xuZnVuY3Rpb24gUSh0KSB7XG4gIGlmICh0eXBlb2Ygc3RydWN0dXJlZENsb25lID09IFwiZnVuY3Rpb25cIilcbiAgICByZXR1cm4gc3RydWN0dXJlZENsb25lKHQpO1xuICB0cnkge1xuICAgIHJldHVybiBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KHQpKTtcbiAgfSBjYXRjaCAobikge1xuICAgIHJldHVybiBjb25zb2xlLndhcm4oXCJGYWlsZWQgdG8gY2xvbmUgZGF0YTpcIiwgdCwgbiksIHQ7XG4gIH1cbn1cbmNvbnN0IGNlID0gW1xuICBcInNpbmdsZUxpbmVcIixcbiAgXCJ0YWdFZGl0b3JcIixcbiAgXCJsaXN0SW5wdXRcIixcbiAgXCJjaGVja2JveFwiLFxuICBcInJpY2hUZXh0RWRpdG9yXCIsXG4gIFwibXVsdGlwbGVMaW5lXCJcbl07XG5mdW5jdGlvbiBQKHQsIG4sIG8sIGUsIHIsIHMsIGMpIHtcbiAgY29uc3QgaSA9IGMgPyBuW2NdIDogbjtcbiAgc3dpdGNoICh0KSB7XG4gICAgY2FzZSBcIlN5bWJvbFwiOiB7XG4gICAgICBjb25zdCB1ID0gdyhpLCBvKTtcbiAgICAgIHAuc2V0KGUsIHIsIHUpO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGNhc2UgXCJUZXh0XCI6IHtcbiAgICAgIGNvbnN0IHUgPSB3KGksIG8pO1xuICAgICAgcC5zZXQoZSwgciwgdSk7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgY2FzZSBcIlJpY2hUZXh0XCI6IHtcbiAgICAgIG9lKHtcbiAgICAgICAgcG9pbnRlcjogXCJcIixcbiAgICAgICAgbWFwcGluZ3M6IHMsXG4gICAgICAgIGRhdGE6IGksXG4gICAgICAgIGhpZGRlblN0cmluZ3M6IG9cbiAgICAgIH0pO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGNhc2UgXCJBcnJheVwiOiB7XG4gICAgICBjb25zdCB1ID0gaS5tYXAoKGEpID0+IHR5cGVvZiBhID09IFwic3RyaW5nXCIgPyB3KGEsIG8pIDogYSk7XG4gICAgICBwLnNldChlLCByLCB1KTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxufVxuY29uc3QgZmUgPSAodCwgbiwgbykgPT4ge1xuICBpZiAoIXQgfHwgIXQuZXh0ZW5zaW9ucyB8fCAhdC5leHRlbnNpb25zLmNvbnRlbnRTb3VyY2VNYXBzKVxuICAgIHJldHVybiBjb25zb2xlLmVycm9yKFxuICAgICAgXCJHcmFwaFFMIHJlc3BvbnNlIGRvZXMgbm90IGNvbnRhaW4gQ29udGVudCBTb3VyY2UgTWFwcyBpbmZvcm1hdGlvbi5cIixcbiAgICAgIHRcbiAgICApLCB0O1xuICBjb25zdCBlID0gUSh0KSwge1xuICAgIHNwYWNlczogcixcbiAgICBlbnZpcm9ubWVudHM6IHMsXG4gICAgZWRpdG9ySW50ZXJmYWNlczogYyxcbiAgICBmaWVsZHM6IGksXG4gICAgbG9jYWxlczogdSxcbiAgICBlbnRyaWVzOiBhLFxuICAgIGFzc2V0czogbCxcbiAgICBtYXBwaW5nczogbSxcbiAgICBmaWVsZFR5cGVzOiB2XG4gIH0gPSBlLmV4dGVuc2lvbnMuY29udGVudFNvdXJjZU1hcHMsIHkgPSBlO1xuICBmb3IgKGNvbnN0IGQgaW4gbSkge1xuICAgIGNvbnN0IHsgc291cmNlOiBmIH0gPSBtW2RdLCBoID0gXCJlbnRyeVwiIGluIGYgPyBhW2YuZW50cnldIDogbFtmLmFzc2V0XSwgTSA9IFwiZW50cnlcIiBpbiBmID8gXCJFbnRyeVwiIDogXCJBc3NldFwiO1xuICAgIGlmICghaClcbiAgICAgIHJldHVybiBlO1xuICAgIGNvbnN0IGcgPSByW2guc3BhY2VdLCBBID0gc1toLmVudmlyb25tZW50XSwgRSA9IGguaWQsIFMgPSBpW2YuZmllbGRdLCBUID0gdVtmLmxvY2FsZV0sIE4gPSBjW2YuZWRpdG9ySW50ZXJmYWNlXSwgSiA9IHZbZi5maWVsZFR5cGVdO1xuICAgIGlmICghKEIoTi53aWRnZXROYW1lc3BhY2UpICYmICFEKE4ud2lkZ2V0SWQpKSAmJiBwLmhhcyh5LCBkKSkge1xuICAgICAgY29uc3QgUiA9IHAuZ2V0KHksIGQpO1xuICAgICAgaWYgKFIgIT09IG51bGwpIHtcbiAgICAgICAgY29uc3QgeiA9IEMoe1xuICAgICAgICAgIGVudGl0eUlkOiBFLFxuICAgICAgICAgIGVudGl0eVR5cGU6IE0sXG4gICAgICAgICAgc3BhY2U6IGcsXG4gICAgICAgICAgZW52aXJvbm1lbnQ6IEEsXG4gICAgICAgICAgZmllbGQ6IFMsXG4gICAgICAgICAgbG9jYWxlOiBULFxuICAgICAgICAgIGVkaXRvckludGVyZmFjZTogTixcbiAgICAgICAgICBmaWVsZFR5cGU6IEosXG4gICAgICAgICAgdGFyZ2V0T3JpZ2luOiBuLFxuICAgICAgICAgIHBsYXRmb3JtOiBvXG4gICAgICAgIH0pO1xuICAgICAgICBQKEosIFIsIHosIHksIGQsIG0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gZTtcbn0sICQgPSAodCwgbiwgbywgZSwgcikgPT4ge1xuICBpZiAoIXQuZmllbGRzKVxuICAgIHJldHVybjtcbiAgY29uc3QgeyBjb250ZW50U291cmNlTWFwczogcyB9ID0gdC5zeXM7XG4gIGlmICghcylcbiAgICByZXR1cm47XG4gIGNvbnN0IHsgbWFwcGluZ3M6IGMgfSA9IHM7XG4gIGZvciAoY29uc3QgaSBpbiBjKSB7XG4gICAgY29uc3QgeyBzb3VyY2U6IHUgfSA9IGNbaV0sIGEgPSB0LnN5cy5zcGFjZS5zeXMuaWQsIGwgPSB0LnN5cy5lbnZpcm9ubWVudC5zeXMuaWQsIG0gPSB0LnN5cy5pZCwgdiA9IHQuc3lzLnR5cGUsIHkgPSBuW3UuZmllbGRUeXBlXSwgZCA9IG9bdS5lZGl0b3JJbnRlcmZhY2VdO1xuICAgIGlmIChCKGQud2lkZ2V0TmFtZXNwYWNlKSAmJiAhRChkLndpZGdldElkKSlcbiAgICAgIGNvbnRpbnVlO1xuICAgIGNvbnN0IGYgPSBpLnN0YXJ0c1dpdGgoXCIvXCIpID8gaSA6IGAvJHtpfWA7XG4gICAgaWYgKHAuaGFzKHQsIGYpKSB7XG4gICAgICBjb25zdCBoID0gcC5nZXQodCwgZik7XG4gICAgICBpZiAoaCA9PT0gbnVsbClcbiAgICAgICAgcmV0dXJuO1xuICAgICAgY29uc3QgZyA9IGYuc3BsaXQoXCIvXCIpLnBvcCgpO1xuICAgICAgaWYgKCFnKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXCJGaWVsZCBuYW1lIGNvdWxkIG5vdCBiZSBleHRyYWN0ZWQgZnJvbSB0aGUgcG9pbnRlclwiLCBmKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3QgQSA9IHQuc3lzLmxvY2FsZTtcbiAgICAgIGlmIChBKSB7XG4gICAgICAgIGNvbnN0IEUgPSBDKHtcbiAgICAgICAgICBlbnRpdHlJZDogbSxcbiAgICAgICAgICBlbnRpdHlUeXBlOiB2LFxuICAgICAgICAgIHNwYWNlOiBhLFxuICAgICAgICAgIGVudmlyb25tZW50OiBsLFxuICAgICAgICAgIGZpZWxkOiBnLFxuICAgICAgICAgIGxvY2FsZTogQSxcbiAgICAgICAgICBlZGl0b3JJbnRlcmZhY2U6IGQsXG4gICAgICAgICAgZmllbGRUeXBlOiB5LFxuICAgICAgICAgIHRhcmdldE9yaWdpbjogZSxcbiAgICAgICAgICBwbGF0Zm9ybTogclxuICAgICAgICB9KTtcbiAgICAgICAgUCh5LCBoLCBFLCB0LCBmLCBjKTtcbiAgICAgIH0gZWxzZVxuICAgICAgICBPYmplY3Qua2V5cyhoKS5mb3JFYWNoKChTKSA9PiB7XG4gICAgICAgICAgY29uc3QgVCA9IEMoe1xuICAgICAgICAgICAgZW50aXR5SWQ6IG0sXG4gICAgICAgICAgICBlbnRpdHlUeXBlOiB2LFxuICAgICAgICAgICAgc3BhY2U6IGEsXG4gICAgICAgICAgICBlbnZpcm9ubWVudDogbCxcbiAgICAgICAgICAgIGZpZWxkOiBnLFxuICAgICAgICAgICAgbG9jYWxlOiBTLFxuICAgICAgICAgICAgZWRpdG9ySW50ZXJmYWNlOiBkLFxuICAgICAgICAgICAgZmllbGRUeXBlOiB5LFxuICAgICAgICAgICAgdGFyZ2V0T3JpZ2luOiBlLFxuICAgICAgICAgICAgcGxhdGZvcm06IHJcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBQKFxuICAgICAgICAgICAgeSxcbiAgICAgICAgICAgIGgsXG4gICAgICAgICAgICBULFxuICAgICAgICAgICAgdCxcbiAgICAgICAgICAgIGAke2Z9LyR7U31gLFxuICAgICAgICAgICAgYyxcbiAgICAgICAgICAgIFNcbiAgICAgICAgICApO1xuICAgICAgICB9KTtcbiAgICB9XG4gIH1cbn0sIGxlID0gKHQsIG4sIG8pID0+IHtcbiAgdmFyIHI7XG4gIGNvbnN0IGUgPSBRKFxuICAgIHRcbiAgKTtcbiAgaWYgKGUuc3lzICYmIFwiaXRlbXNcIiBpbiBlKSB7XG4gICAgY29uc3QgcyA9IGU7XG4gICAgaWYgKCEoKHIgPSBzLnN5cykgIT0gbnVsbCAmJiByLmNvbnRlbnRTb3VyY2VNYXBzTG9va3VwKSlcbiAgICAgIHJldHVybiBzO1xuICAgIGNvbnN0IHtcbiAgICAgIGNvbnRlbnRTb3VyY2VNYXBzTG9va3VwOiB7IGZpZWxkVHlwZXM6IGMsIGVkaXRvckludGVyZmFjZXM6IGkgfVxuICAgIH0gPSBzLnN5cywgeyBpdGVtczogdSwgaW5jbHVkZXM6IGEgfSA9IHM7XG4gICAgdS5mb3JFYWNoKFxuICAgICAgKGwpID0+ICQobCwgYywgaSwgbiwgbylcbiAgICApLCBhICYmIGEuRW50cnkgJiYgYS5FbnRyeS5mb3JFYWNoKFxuICAgICAgKGwpID0+ICQobCwgYywgaSwgbiwgbylcbiAgICApLCBhICYmIGEuQXNzZXQgJiYgYS5Bc3NldC5mb3JFYWNoKFxuICAgICAgKGwpID0+ICQobCwgYywgaSwgbiwgbylcbiAgICApO1xuICB9IGVsc2Uge1xuICAgIGNvbnN0IHMgPSBlO1xuICAgIGlmICghcy5zeXMuY29udGVudFNvdXJjZU1hcHNMb29rdXApXG4gICAgICByZXR1cm4gY29uc29sZS5lcnJvcihcIkNvbnRlbnQgc291cmNlIG1hcHMgbG9va3VwIGRhdGEgaXMgbWlzc2luZ1wiKSwgcztcbiAgICAkKFxuICAgICAgcyxcbiAgICAgIHMuc3lzLmNvbnRlbnRTb3VyY2VNYXBzTG9va3VwLmZpZWxkVHlwZXMsXG4gICAgICBzLnN5cy5jb250ZW50U291cmNlTWFwc0xvb2t1cC5lZGl0b3JJbnRlcmZhY2VzLFxuICAgICAgbixcbiAgICAgIG9cbiAgICApO1xuICB9XG4gIHJldHVybiBlO1xufTtcbmV4cG9ydCB7XG4gIGNlIGFzIFNVUFBPUlRFRF9XSURHRVRTLFxuICBRIGFzIGNsb25lLFxuICB3IGFzIGNvbWJpbmUsXG4gIEMgYXMgY3JlYXRlU291cmNlTWFwTWV0YWRhdGEsXG4gIGFlIGFzIGRlY29kZSxcbiAgaWUgYXMgZW5jb2RlLFxuICBsZSBhcyBlbmNvZGVDUEFSZXNwb25zZSxcbiAgUCBhcyBlbmNvZGVGaWVsZCxcbiAgZmUgYXMgZW5jb2RlR3JhcGhRTFJlc3BvbnNlLFxuICBvZSBhcyBlbmNvZGVSaWNoVGV4dFZhbHVlLFxuICBCIGFzIGlzQnVpbHRpbk5hbWVzcGFjZSxcbiAgRCBhcyBpc1N1cHBvcnRlZFdpZGdldCxcbiAgdWUgYXMgc3BsaXRFbmNvZGluZ1xufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@contentful/content-source-maps/dist/index.js\n");

/***/ })

};
;